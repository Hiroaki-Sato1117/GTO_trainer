<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTO Poker Trainer v7</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* メインレイアウト */
        .game-container {
            display: grid;
            grid-template-rows: auto 1fr;
            height: 100vh;
            width: 100%;
        }

        /* ヘッダー2段構成 */
        .header {
            background: rgba(0,0,0,0.5);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .app-title {
            color: #fbbf24;
            font-weight: bold;
            font-size: 16px;
        }

        .blinds-info {
            color: #9ca3af;
            font-size: 14px;
        }

        .control-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 20px;
        }

        /* タブボタン */
        .tab-buttons {
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 3px;
            border-radius: 8px;
        }

        .tab-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
            background: transparent;
            color: #9ca3af;
        }

        .tab-btn.active {
            background: #4c1d95;
            color: white;
        }

        .tab-btn:hover:not(.active) {
            background: rgba(255,255,255,0.1);
        }

        .toggle-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        .toggle-btn.active {
            background: #3b82f6;
            color: white;
        }
        .toggle-btn.inactive {
            background: #374151;
            color: #9ca3af;
        }
        .toggle-btn:hover {
            filter: brightness(1.1);
        }

        /* 3カラム構造 */
        .content-area {
            display: grid;
            overflow: hidden;
            transition: grid-template-columns 0.3s ease;
        }

        .content-2col-left {
            grid-template-columns: 250px 1fr;
        }
        .content-3col {
            grid-template-columns: 250px 1fr 300px;
        }

        /* 左パネル */
        .left-panel {
            background: rgba(0,0,0,0.4);
            border-right: 1px solid rgba(255,255,255,0.1);
            padding: 12px;
            overflow-y: auto;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            color: white;
        }

        .close-btn {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
        }
        .close-btn:hover { color: white; }

        /* 右パネル - GTO推奨 */
        .right-panel {
            background: linear-gradient(180deg, rgba(88,28,135,0.9), rgba(59,7,100,0.9));
            border-left: 1px solid rgba(168,85,247,0.3);
            padding: 16px;
            overflow-y: auto;
        }

        /* メインエリア */
        .main-area {
            display: grid;
            grid-template-rows: 1fr 100px 80px;
            overflow: visible;
        }

        /* テーブルエリア */
        .table-area {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px 20px 50px 20px;
            overflow: visible;
        }

        .poker-table {
            position: relative;
            width: 650px;
            height: 320px;
        }

        .table-felt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            height: 240px;
            background: radial-gradient(ellipse, #1e6b3a 0%, #145028 60%, #0d3d1c 100%);
            border-radius: 120px;
            border: 10px solid #5c3d2e;
            box-shadow: 0 0 0 3px #8b6914, 0 0 30px rgba(0,0,0,0.5), inset 0 0 50px rgba(0,0,0,0.3);
        }

        /* プレイヤー配置 */
        .player-seat {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .seat-player-1 { bottom: 15px; left: -35px; }
        .seat-player-2 { top: 15px; left: -35px; }
        .seat-player-3 { top: -55px; left: 50%; transform: translateX(-50%); }
        .seat-player-4 { top: 15px; right: -35px; }
        .seat-player-5 { bottom: 15px; right: -35px; }

        .player-seat.active .player-box {
            box-shadow: 0 0 15px #fbbf24, 0 0 30px rgba(251,191,36,0.4);
            border-color: #fbbf24;
        }
        .player-seat.folded { opacity: 0.35; }

        .player-box {
            background: linear-gradient(to bottom, #2a2a3a, #1a1a2a);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 6px 10px;
            min-width: 90px;
            text-align: center;
        }

        .player-cards {
            display: flex;
            gap: 2px;
            margin-bottom: 4px;
        }

        /* アクションラベル */
        .action-label {
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            color: white;
            white-space: nowrap;
            animation: fadeIn 0.3s ease;
        }
        .action-label.fold { background: #6b7280; }
        .action-label.raise { background: #f59e0b; }
        .action-label.call { background: #22c55e; }
        .action-label.check { background: #3b82f6; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-8px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* カード */
        .card {
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        .card-xs { width: 24px; height: 32px; font-size: 8px; }
        .card-sm { width: 32px; height: 44px; font-size: 10px; }
        .card-md { width: 44px; height: 60px; font-size: 14px; }
        .card-lg { width: 60px; height: 84px; font-size: 18px; }

        .card-back {
            background: linear-gradient(135deg, #8b0000, #4a0000);
            border: 2px solid #ffd700;
        }
        .card-front {
            background: linear-gradient(to bottom, #fff, #f0f0f0);
            border: 2px solid #333;
        }
        .red { color: #dc2626; }
        .black { color: #1a1a1a; }

        /* ポジションバッジ */
        .pos-badge {
            font-size: 9px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            color: white;
            display: inline-block;
        }
        .pos-BTN { background: #f97316; }
        .pos-SB { background: #3b82f6; }
        .pos-BB { background: #22c55e; }
        .pos-UTG { background: #ef4444; }
        .pos-HJ { background: #eab308; }
        .pos-CO { background: #a855f7; }

        /* コミュニティエリア */
        .community-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .community-cards {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 6px;
        }

        /* 自分のエリア */
        .hero-area {
            background: linear-gradient(to bottom, rgba(30,58,95,0.9), rgba(13,31,60,0.9));
            border-top: 2px solid #3b82f6;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 24px;
            padding: 8px 12px;
            position: relative;
            z-index: 10;
        }

        .hero-cards {
            display: flex;
            gap: 6px;
        }

        .hero-info {
            text-align: center;
        }

        /* アクションエリア */
        .action-area {
            background: linear-gradient(to bottom, #1f2937, #111827);
            border-top: 1px solid #374151;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
        }

        .action-row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100px;
            height: 70px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 15px;
            color: white;
            cursor: pointer;
            border: 2px solid;
            transition: all 0.15s;
        }
        .action-btn:hover { transform: scale(1.03); filter: brightness(1.1); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
        .action-btn .amount { color: #fbbf24; font-size: 13px; margin-top: 2px; font-weight: 600; }
        .action-btn .shortcut { color: rgba(255,255,255,0.4); font-size: 10px; margin-top: 1px; }
        .btn-fold { background: #6b7280; border-color: #9ca3af; }
        .btn-check { background: #6b7280; border-color: #9ca3af; }
        .btn-call { background: #16a34a; border-color: #22c55e; }
        .btn-raise { background: #ea580c; border-color: #f97316; }

        .size-btn {
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            color: #fbbf24;
            background: #854d0e;
            border: 2px solid #a16207;
            cursor: pointer;
            transition: all 0.15s;
        }
        .size-btn:hover { filter: brightness(1.15); }
        .size-btn.active { background: #ca8a04; border-color: #fbbf24; color: #1a1a2e; }

        .bet-slider {
            width: 160px;
            height: 5px;
            border-radius: 3px;
            background: linear-gradient(to right, #22c55e, #f59e0b, #ef4444);
            -webkit-appearance: none;
            cursor: pointer;
        }
        .bet-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            border: 2px solid #3b82f6;
            cursor: pointer;
        }

        .bet-input {
            width: 70px;
            padding: 5px 8px;
            border-radius: 5px;
            background: #1f2937;
            border: 1px solid #374151;
            color: white;
            font-size: 13px;
            text-align: center;
        }

        /* レンジ表 */
        .range-info {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .range-title {
            font-size: 12px;
            font-weight: bold;
            color: #a5b4fc;
            margin-bottom: 8px;
        }

        .range-grid {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 1px;
        }

        .range-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            font-weight: bold;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .range-cell:hover {
            transform: scale(1.4);
            z-index: 10;
        }
        .range-cell.raise { background: #f59e0b; color: white; }
        .range-cell.call { background: #22c55e; color: white; }
        .range-cell.fold { background: #374151; color: #6b7280; }
        .range-cell.current {
            box-shadow: 0 0 0 2px #fff, 0 0 6px #fff;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 2px #fff, 0 0 6px #fff; }
            50% { box-shadow: 0 0 0 3px #fbbf24, 0 0 10px #fbbf24; }
        }

        .range-legend {
            display: flex;
            gap: 12px;
            margin-top: 10px;
            font-size: 10px;
            color: #9ca3af;
        }
        .range-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .range-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .current-hand-info {
            margin-top: 12px;
            padding: 10px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 6px;
            text-align: center;
        }

        /* GTO推奨 */
        .progress-bar {
            height: 26px;
            border-radius: 5px;
            overflow: hidden;
            display: flex;
            background: #374151;
            margin-bottom: 14px;
        }
        .progress-bar > div {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
        }

        .gto-section {
            margin-bottom: 14px;
        }

        .gto-section-title {
            font-size: 11px;
            font-weight: bold;
            color: #c4b5fd;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .gto-item {
            font-size: 11px;
            color: #e0e0e0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            align-items: flex-start;
            gap: 5px;
        }
        .gto-item:last-child { border-bottom: none; }

        .gto-bullet {
            color: #a855f7;
            flex-shrink: 0;
        }

        /* フィードバックモーダル */
        .feedback-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.25s ease, visibility 0.25s ease, background 0.25s ease;
            will-change: opacity, visibility;
        }

        .feedback-overlay.show {
            opacity: 1;
            visibility: visible;
            background: rgba(0,0,0,0.7);
        }

        .feedback-modal {
            background: linear-gradient(135deg, #1f2937, #111827);
            border-radius: 16px;
            padding: 30px 40px;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: scale(0.85) translateZ(0);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.25s ease;
            will-change: transform, opacity;
            backface-visibility: hidden;
        }

        .feedback-overlay.show .feedback-modal {
            transform: scale(1) translateZ(0);
            opacity: 1;
        }

        .feedback-icon {
            font-size: 60px;
            margin-bottom: 16px;
        }

        .feedback-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 16px;
        }
        .feedback-title.correct { color: #22c55e; }
        .feedback-title.error { color: #ef4444; }
        .feedback-title.acceptable { color: #f59e0b; }

        .feedback-details {
            color: #9ca3af;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .feedback-message {
            color: white;
            font-size: 15px;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .feedback-btn {
            padding: 12px 32px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            color: white;
            background: #3b82f6;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        .feedback-btn:hover {
            background: #2563eb;
            transform: scale(1.05);
        }

        /* 処理中インジケーター */
        .processing-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px;
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.5);
            border-radius: 8px;
            color: #fbbf24;
            font-size: 13px;
        }

        .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(251,191,36,0.3);
            border-top-color: #fbbf24;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .waiting-message {
            text-align: center;
            padding: 16px;
            color: #9ca3af;
            font-size: 14px;
        }

        /* 統計パネル */
        .stats-section {
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .stats-section:last-child { border-bottom: none; }

        .stats-main-section {
            text-align: center;
        }

        .stats-big-number {
            font-size: 42px;
            font-weight: bold;
            color: #22c55e;
        }

        .stats-label {
            color: #9ca3af;
            font-size: 14px;
        }

        .stats-sub {
            color: #6b7280;
            font-size: 12px;
            margin-top: 4px;
        }

        .stats-section-title {
            color: #fbbf24;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .stats-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .stats-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
        }

        .stats-item-label {
            color: #9ca3af;
            font-size: 10px;
        }

        .stats-item-value {
            color: white;
            font-size: 16px;
            font-weight: bold;
        }

        .stats-item-count {
            color: #6b7280;
            font-size: 9px;
        }

        /* 履歴 */
        .history-toggle {
            width: 100%;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border: none;
            border-radius: 6px;
            color: #9ca3af;
            cursor: pointer;
            text-align: left;
            font-size: 12px;
        }

        .history-toggle:hover {
            background: rgba(0,0,0,0.3);
        }

        .history-list {
            margin-top: 10px;
            max-height: 180px;
            overflow-y: auto;
        }

        .history-item {
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 11px;
        }

        .history-header {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 4px;
        }

        .history-hand {
            color: #fbbf24;
            font-weight: bold;
            font-size: 13px;
        }

        .history-position {
            color: #60a5fa;
        }

        .history-situation {
            color: #9ca3af;
        }

        .history-detail {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .history-wrong {
            color: #ef4444;
        }

        .history-correct {
            color: #22c55e;
        }

        .history-time {
            color: #4b5563;
            font-size: 9px;
            margin-top: 4px;
        }

        .history-empty {
            color: #9ca3af;
            text-align: center;
            padding: 16px;
            font-size: 12px;
        }

        .stats-footer {
            text-align: center;
            padding-top: 8px;
        }

        .reset-btn {
            padding: 8px 16px;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: #9ca3af;
            cursor: pointer;
            font-size: 11px;
        }

        .reset-btn:hover {
            background: #4b5563;
            color: white;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        const API_BASE = '/api';
        const SUIT_SYMBOLS = { hearts: '\u2665', diamonds: '\u2666', clubs: '\u2663', spades: '\u2660' };
        const RANK_NAMES = { 2:'2', 3:'3', 4:'4', 5:'5', 6:'6', 7:'7', 8:'8', 9:'9', 10:'T', 11:'J', 12:'Q', 13:'K', 14:'A' };
        const RANGE_LABELS = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'];

        // ============================================
        // ローカルストレージ
        // ============================================
        const STATS_STORAGE_KEY = 'gto_trainer_stats';
        const HISTORY_STORAGE_KEY = 'gto_trainer_history';

        const initialStats = {
            totalHands: 0,
            correctActions: 0,
            byPosition: {
                UTG: { total: 0, correct: 0 },
                HJ: { total: 0, correct: 0 },
                CO: { total: 0, correct: 0 },
                BTN: { total: 0, correct: 0 },
                SB: { total: 0, correct: 0 },
                BB: { total: 0, correct: 0 }
            },
            bySituation: {
                RFI: { total: 0, correct: 0 },
                vsOpen: { total: 0, correct: 0 }
            },
            byAction: {
                fold: { total: 0, correct: 0 },
                call: { total: 0, correct: 0 },
                raise: { total: 0, correct: 0 }
            }
        };

        const loadStats = () => {
            try {
                const saved = localStorage.getItem(STATS_STORAGE_KEY);
                return saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(initialStats));
            } catch (e) {
                return JSON.parse(JSON.stringify(initialStats));
            }
        };

        const saveStats = (stats) => {
            try { localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(stats)); } catch (e) {}
        };

        const loadHistory = () => {
            try {
                const saved = localStorage.getItem(HISTORY_STORAGE_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        };

        const saveHistory = (history) => {
            try { localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history.slice(-100))); } catch (e) {}
        };

        // ============================================
        // コンポーネント
        // ============================================

        // カードコンポーネント
        function Card({ card, faceDown, size = 'sm' }) {
            const sizeClass = {xs:'card-xs', sm:'card-sm', md:'card-md', lg:'card-lg'}[size] || 'card-sm';
            if (faceDown || !card) return <div className={`card card-back ${sizeClass}`} />;
            const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
            return (
                <div className={`card card-front ${sizeClass}`}>
                    <span className={isRed ? 'red' : 'black'}>{RANK_NAMES[card.rank]}</span>
                    <span className={isRed ? 'red' : 'black'}>{SUIT_SYMBOLS[card.suit]}</span>
                </div>
            );
        }

        // ハンド表記を取得
        function getHandNotation(cards) {
            if (!cards || cards.length !== 2) return null;
            const sorted = [...cards].sort((a, b) => b.rank - a.rank);
            const r1 = RANK_NAMES[sorted[0].rank];
            const r2 = RANK_NAMES[sorted[1].rank];
            const suited = sorted[0].suit === sorted[1].suit ? 's' : 'o';
            if (sorted[0].rank === sorted[1].rank) return r1 + r2;
            return r1 + r2 + suited;
        }

        // プレイヤーコンポーネント
        function PlayerSeat({ player, isActive, seatClass }) {
            const actionClass = player.lastAction ? player.lastAction.toLowerCase() : '';
            return (
                <div className={`player-seat ${seatClass} ${isActive ? 'active' : ''} ${player.isFolded ? 'folded' : ''}`}>
                    {player.lastAction && !player.isFolded && (
                        <div className={`action-label ${actionClass}`}>
                            {player.lastAction === 'raise' ? `Raise ${player.lastActionAmount}` :
                             player.lastAction === 'call' ? `Call ${player.lastActionAmount}` :
                             player.lastAction === 'fold' ? 'Fold' :
                             player.lastAction === 'check' ? 'Check' :
                             player.lastAction}
                        </div>
                    )}
                    <div className="player-cards">
                        <Card faceDown={true} size="xs" />
                        <Card faceDown={true} size="xs" />
                    </div>
                    <div className="player-box">
                        <div style={{marginBottom: '3px'}}>
                            <span className={`pos-badge pos-${player.position}`}>{player.position}</span>
                        </div>
                        <div className="text-white text-xs">{player.name}</div>
                        <div className="text-yellow-400 text-xs font-bold">{player.stack.toLocaleString()}</div>
                        {player.currentBet > 0 && <div className="text-green-400" style={{fontSize: '10px'}}>Bet: {player.currentBet}</div>}
                        {player.isFolded && <div className="text-red-400" style={{fontSize: '10px'}}>FOLD</div>}
                    </div>
                </div>
            );
        }

        // レンジパネル（APIからデータ取得）
        function RangePanel({ heroPosition, heroHand, firstRaiser }) {
            const [rangeMatrix, setRangeMatrix] = useState(null);
            const [rangeTitle, setRangeTitle] = useState('');
            const [loading, setLoading] = useState(true);
            const handNotation = heroHand ? getHandNotation(heroHand) : null;

            useEffect(() => {
                const fetchRange = async () => {
                    setLoading(true);
                    try {
                        let url;
                        if (firstRaiser) {
                            url = `${API_BASE}/range?type=VS_OPEN&heroPosition=${heroPosition}&openerPosition=${firstRaiser}`;
                        } else {
                            url = `${API_BASE}/range?type=RFI&heroPosition=${heroPosition}`;
                        }
                        const res = await fetch(url);
                        const data = await res.json();
                        if (data.success) {
                            setRangeMatrix(data.matrix);
                            setRangeTitle(data.title);
                        } else {
                            setRangeMatrix(null);
                        }
                    } catch (err) {
                        console.error('Range fetch error:', err);
                        setRangeMatrix(null);
                    }
                    setLoading(false);
                };
                fetchRange();
            }, [heroPosition, firstRaiser]);

            const getCellHand = (row, col) => {
                const r1 = RANGE_LABELS[row];
                const r2 = RANGE_LABELS[col];
                if (row === col) return r1 + r2;
                if (row < col) return r1 + r2 + 's';
                return r2 + r1 + 'o';
            };

            const getCellClass = (row, col) => {
                if (!rangeMatrix) return 'fold';
                const value = rangeMatrix[row]?.[col] || 0;
                if (value === 2) return 'raise';
                if (value === 1) return 'call';
                return 'fold';
            };

            const isCurrentHand = (row, col) => {
                if (!handNotation) return false;
                return getCellHand(row, col) === handNotation;
            };

            const isInRange = () => {
                if (!handNotation || !rangeMatrix) return false;
                for (let r = 0; r < 13; r++) {
                    for (let c = 0; c < 13; c++) {
                        if (getCellHand(r, c) === handNotation && rangeMatrix[r]?.[c] > 0) return true;
                    }
                }
                return false;
            };

            const legend = firstRaiser
                ? [{ label: '3bet/Raise', color: '#f59e0b' }, { label: 'コール', color: '#22c55e' }, { label: 'フォールド', color: '#374151' }]
                : [{ label: 'オープン', color: '#f59e0b' }, { label: 'フォールド', color: '#374151' }];

            if (loading) {
                return (
                    <div style={{color: '#9ca3af', textAlign: 'center', padding: '20px'}}>
                        読み込み中...
                    </div>
                );
            }

            return (
                <>
                    <div className="range-info">
                        <div className="range-title">{rangeTitle || `${heroPosition} Range`}</div>
                        {firstRaiser && (
                            <div style={{fontSize: '10px', color: '#9ca3af', marginBottom: '8px'}}>
                                vs {firstRaiser} Open
                            </div>
                        )}

                        {rangeMatrix ? (
                            <>
                                <div className="range-grid">
                                    {RANGE_LABELS.map((_, row) =>
                                        RANGE_LABELS.map((_, col) => {
                                            const cellHand = getCellHand(row, col);
                                            const isCurrent = isCurrentHand(row, col);
                                            return (
                                                <div
                                                    key={`${row}-${col}`}
                                                    className={`range-cell ${getCellClass(row, col)} ${isCurrent ? 'current' : ''}`}
                                                    title={cellHand}
                                                >
                                                    {cellHand.substring(0, 2)}
                                                </div>
                                            );
                                        })
                                    )}
                                </div>

                                <div className="range-legend">
                                    {legend.map((item, i) => (
                                        <div key={i} className="range-legend-item">
                                            <div className="range-legend-color" style={{background: item.color}} />
                                            <span>{item.label}</span>
                                        </div>
                                    ))}
                                </div>
                            </>
                        ) : (
                            <div style={{color: '#9ca3af', textAlign: 'center', padding: '12px', fontSize: '12px'}}>
                                このシチュエーションのレンジデータはありません
                            </div>
                        )}
                    </div>

                    {handNotation && rangeMatrix && (
                        <div className="current-hand-info">
                            <div className="text-white font-bold text-sm mb-1">
                                現在のハンド: {handNotation}
                            </div>
                            <div className={isInRange() ? 'text-green-400' : 'text-red-400'} style={{fontSize: '12px'}}>
                                {isInRange() ? 'レンジ内' : 'レンジ外'}
                            </div>
                        </div>
                    )}
                </>
            );
        }

        // GTO推奨パネル
        function GTOPanel({ recommendation, onClose }) {
            if (!recommendation) {
                return (
                    <div className="right-panel">
                        <div className="panel-header">
                            <div className="panel-title"><span>GTO推奨</span></div>
                            <button className="close-btn" onClick={onClose}>−</button>
                        </div>
                        <div style={{color: '#9ca3af', textAlign: 'center', padding: '30px 0'}}>
                            あなたのターンになると<br/>GTO推奨が表示されます
                        </div>
                    </div>
                );
            }

            if (recommendation.isUnimplemented) {
                return (
                    <div className="right-panel">
                        <div className="panel-header">
                            <div className="panel-title"><span>GTO推奨</span></div>
                            <button className="close-btn" onClick={onClose}>−</button>
                        </div>
                        {recommendation.hand_notation && (
                            <div style={{textAlign: 'center', marginBottom: '12px'}}>
                                <span className="text-yellow-400 font-bold text-lg">{recommendation.hand_notation}</span>
                            </div>
                        )}
                        <div style={{background: 'rgba(251, 191, 36, 0.2)', border: '1px solid rgba(251, 191, 36, 0.5)', borderRadius: '8px', padding: '16px', marginBottom: '16px'}}>
                            <div style={{color: '#fbbf24', fontWeight: 'bold', fontSize: '14px', marginBottom: '8px', display: 'flex', alignItems: 'center', gap: '8px'}}>
                                <span>&#x26A0;&#xFE0F;</span>
                                <span>未実装のシチュエーション</span>
                            </div>
                            <div style={{color: '#fcd34d', fontSize: '13px', marginBottom: '8px'}}>{recommendation.message}</div>
                            <div style={{color: '#d1d5db', fontSize: '11px'}}>{recommendation.description}</div>
                        </div>
                        <div style={{color: '#9ca3af', fontSize: '11px', textAlign: 'center'}}>
                            このシチュエーションでは、<br/>ご自身の判断でプレイしてください。
                        </div>
                    </div>
                );
            }

            const {
                fold_percentage = 0, call_percentage = 0, raise_percentage = 0,
                situation_analysis = [], reasoning = [],
                raise_size_description, raise_reasoning, hand_notation
            } = recommendation;

            return (
                <div className="right-panel">
                    <div className="panel-header">
                        <div className="panel-title"><span>GTO推奨</span></div>
                        <button className="close-btn" onClick={onClose}>−</button>
                    </div>
                    {hand_notation && (
                        <div style={{textAlign: 'center', marginBottom: '12px'}}>
                            <span className="text-yellow-400 font-bold text-lg">{hand_notation}</span>
                        </div>
                    )}
                    <div className="progress-bar">
                        {fold_percentage > 0 && <div style={{width: `${fold_percentage}%`, background: '#6b7280'}}>Fold {fold_percentage}%</div>}
                        {call_percentage > 0 && <div style={{width: `${call_percentage}%`, background: '#22c55e'}}>Call {call_percentage}%</div>}
                        {raise_percentage > 0 && <div style={{width: `${raise_percentage}%`, background: '#f59e0b'}}>Raise {raise_percentage}%</div>}
                    </div>
                    {situation_analysis.length > 0 && (
                        <div className="gto-section">
                            <div className="gto-section-title">状況分析</div>
                            {situation_analysis.map((item, i) => (
                                <div key={i} className="gto-item"><span className="gto-bullet">•</span><span>{item}</span></div>
                            ))}
                        </div>
                    )}
                    {reasoning.length > 0 && (
                        <div className="gto-section">
                            <div className="gto-section-title">推奨理由</div>
                            {reasoning.map((item, i) => (
                                <div key={i} className="gto-item"><span className="gto-bullet">•</span><span>{item}</span></div>
                            ))}
                        </div>
                    )}
                    {raise_percentage > 0 && raise_size_description && (
                        <div className="gto-section">
                            <div className="gto-section-title">レイズサイズ</div>
                            <div className="text-yellow-300 text-sm font-bold mb-1">{raise_size_description}</div>
                            {raise_reasoning && <div className="text-gray-300" style={{fontSize: '11px'}}>{raise_reasoning}</div>}
                        </div>
                    )}
                </div>
            );
        }

        // 統計パネル
        function StatsPanel({ stats, history, onReset }) {
            const [showHistory, setShowHistory] = useState(false);

            const calcRate = (correct, total) => {
                if (total === 0) return '\u2014';
                return Math.round((correct / total) * 100) + '%';
            };

            const overallRate = calcRate(stats.correctActions, stats.totalHands);

            return (
                <>
                    {/* 総合成績 */}
                    <div className="stats-section stats-main-section">
                        <div className="stats-big-number">{overallRate}</div>
                        <div className="stats-label">正解率</div>
                        <div className="stats-sub">総ハンド数: {stats.totalHands}</div>
                    </div>

                    {/* ポジション別 */}
                    <div className="stats-section">
                        <div className="stats-section-title">ポジション別</div>
                        <div className="stats-grid">
                            {Object.entries(stats.byPosition).map(([pos, data]) => (
                                <div key={pos} className="stats-item">
                                    <span className="stats-item-label">{pos}</span>
                                    <span className="stats-item-value">{calcRate(data.correct, data.total)}</span>
                                    <span className="stats-item-count">({data.total})</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* シチュエーション別 */}
                    <div className="stats-section">
                        <div className="stats-section-title">シチュエーション別</div>
                        <div className="stats-grid stats-grid-2">
                            <div className="stats-item">
                                <span className="stats-item-label">RFI</span>
                                <span className="stats-item-value">{calcRate(stats.bySituation.RFI.correct, stats.bySituation.RFI.total)}</span>
                                <span className="stats-item-count">({stats.bySituation.RFI.total})</span>
                            </div>
                            <div className="stats-item">
                                <span className="stats-item-label">vs Open</span>
                                <span className="stats-item-value">{calcRate(stats.bySituation.vsOpen.correct, stats.bySituation.vsOpen.total)}</span>
                                <span className="stats-item-count">({stats.bySituation.vsOpen.total})</span>
                            </div>
                        </div>
                    </div>

                    {/* アクション別 */}
                    <div className="stats-section">
                        <div className="stats-section-title">アクション別</div>
                        <div className="stats-grid">
                            {Object.entries(stats.byAction).map(([action, data]) => (
                                <div key={action} className="stats-item">
                                    <span className="stats-item-label">{action}</span>
                                    <span className="stats-item-value">{calcRate(data.correct, data.total)}</span>
                                    <span className="stats-item-count">({data.total})</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* 間違えた問題履歴 */}
                    <div className="stats-section">
                        <button className="history-toggle" onClick={() => setShowHistory(!showHistory)}>
                            {showHistory ? '\u25BC' : '\u25B6'} 間違えた問題 ({history.length})
                        </button>
                        {showHistory && (
                            <div className="history-list">
                                {history.length === 0 ? (
                                    <div className="history-empty">まだ間違いはありません</div>
                                ) : (
                                    history.slice().reverse().map(item => (
                                        <div key={item.id} className="history-item">
                                            <div className="history-header">
                                                <span className="history-hand">{item.hand}</span>
                                                <span className="history-position">{item.position}</span>
                                                <span className="history-situation">{item.situation}</span>
                                            </div>
                                            <div className="history-detail">
                                                <span className="history-wrong">x {item.yourAction}</span>
                                                <span style={{color: '#6b7280'}}>&rarr;</span>
                                                <span className="history-correct">o {item.correctAction}</span>
                                            </div>
                                            <div className="history-time">{item.timestamp}</div>
                                        </div>
                                    ))
                                )}
                            </div>
                        )}
                    </div>

                    {/* リセットボタン */}
                    <div className="stats-footer">
                        <button className="reset-btn" onClick={() => {
                            if (confirm('統計をリセットしますか？')) onReset();
                        }}>
                            統計をリセット
                        </button>
                    </div>
                </>
            );
        }

        // フィードバックモーダル
        function FeedbackModal({ feedback, onNextHand }) {
            const lastFeedbackRef = useRef(null);
            if (feedback) lastFeedbackRef.current = feedback;

            const displayFeedback = feedback || lastFeedbackRef.current;
            const { result, userAction, gtoRecommendation, message } = displayFeedback || {};

            const resultConfig = {
                CORRECT: { icon: '', title: 'CORRECT', class: 'correct' },
                ERROR: { icon: '', title: 'ERROR', class: 'error' },
                ACCEPTABLE: { icon: '', title: 'ACCEPTABLE', class: 'acceptable' }
            };

            const config = resultConfig[result] || resultConfig.CORRECT;
            const isOpen = !!feedback;

            return (
                <div className={`feedback-overlay ${isOpen ? 'show' : ''}`} onClick={onNextHand}>
                    <div className="feedback-modal" onClick={e => e.stopPropagation()}>
                        <div className="feedback-icon">{config.icon}</div>
                        <div className={`feedback-title ${config.class}`}>{config.title}</div>
                        <div className="feedback-details">
                            あなたの選択: {userAction || '-'}
                        </div>
                        <div className="feedback-details">
                            {gtoRecommendation?.isUnimplemented
                              ? `GTO推奨: ${gtoRecommendation.message}`
                              : `GTO推奨: Fold ${gtoRecommendation?.fold_percentage || 0}% / Call ${gtoRecommendation?.call_percentage || 0}% / Raise ${gtoRecommendation?.raise_percentage || 0}%`
                            }
                        </div>
                        <div className="feedback-message">{message || ''}</div>
                        <button className="feedback-btn" onClick={onNextHand}>
                            次のハンドへ
                        </button>
                        <div style={{color: '#9ca3af', fontSize: '11px', marginTop: '6px'}}>
                            スペースキー
                        </div>
                    </div>
                </div>
            );
        }

        // ============================================
        // メインアプリ
        // ============================================
        function App() {
            const [game, setGame] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [isProcessingAI, setIsProcessingAI] = useState(false);
            const [gtoRecommendation, setGtoRecommendation] = useState(null);
            const [betAmount, setBetAmount] = useState(300);
            const [showGTOPanel, setShowGTOPanel] = useState(true);
            const [leftPanelMode, setLeftPanelMode] = useState('range');
            const [feedback, setFeedback] = useState(null);
            const [stats, setStats] = useState(() => loadStats());
            const [handHistory, setHandHistory] = useState(() => loadHistory());

            // 統計・履歴の自動保存
            useEffect(() => { saveStats(stats); }, [stats]);
            useEffect(() => { saveHistory(handHistory); }, [handHistory]);

            // グリッドカラムを動的に計算（左パネルは常に表示）
            const contentClass = useMemo(() => {
                return showGTOPanel ? 'content-area content-3col' : 'content-area content-2col-left';
            }, [showGTOPanel]);

            // AIアクションを順次処理
            const processAIActions = async () => {
                setIsProcessingAI(true);
                let heroAutoWin = false;
                while (true) {
                    await new Promise(resolve => setTimeout(resolve, 400));
                    try {
                        const res = await fetch(`${API_BASE}/game/next-ai-action`);
                        const data = await res.json();
                        if (!data.action) break;
                        setGame(data.action.game);
                        if (data.action.heroAutoWin) {
                            heroAutoWin = true;
                            break;
                        }
                        if (!data.hasMore) break;
                    } catch (err) {
                        console.error('AI action error:', err);
                        break;
                    }
                }
                setIsProcessingAI(false);

                if (heroAutoWin) {
                    await new Promise(resolve => setTimeout(resolve, 800));
                    await proceedToNextHand();
                    return;
                }

                try {
                    const gtoRes = await fetch(`${API_BASE}/game/gto-recommendation`);
                    const gtoData = await gtoRes.json();
                    setGtoRecommendation(gtoData.recommendation);
                } catch (err) {
                    console.error('GTO fetch error:', err);
                }
            };

            // 次のハンドへ進む（内部用）
            const proceedToNextHand = async () => {
                setGtoRecommendation(null);
                setFeedback(null);
                try {
                    const res = await fetch(`${API_BASE}/game/next-hand`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await res.json();
                    setGame(data.game);
                    setBetAmount(data.game.blinds.bb * 3);
                    if (data.pendingActionsCount > 0) {
                        await processAIActions();
                    } else {
                        const gtoRes = await fetch(`${API_BASE}/game/gto-recommendation`);
                        const gtoData = await gtoRes.json();
                        setGtoRecommendation(gtoData.recommendation);
                    }
                } catch (err) {
                    console.error(err);
                }
            };

            const startNewGame = useCallback(async () => {
                setIsLoading(true);
                setGtoRecommendation(null);
                setFeedback(null);
                try {
                    const res = await fetch(`${API_BASE}/game/new`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await res.json();
                    setGame(data.game);
                    setBetAmount(data.game.blinds.bb * 3);
                    setIsLoading(false);
                    if (data.pendingActionsCount > 0) {
                        await processAIActions();
                    } else {
                        const gtoRes = await fetch(`${API_BASE}/game/gto-recommendation`);
                        const gtoData = await gtoRes.json();
                        setGtoRecommendation(gtoData.recommendation);
                    }
                } catch (err) {
                    console.error(err);
                    setIsLoading(false);
                }
            }, []);

            const nextHand = useCallback(async () => {
                setIsLoading(true);
                setGtoRecommendation(null);
                setFeedback(null);
                try {
                    const res = await fetch(`${API_BASE}/game/next-hand`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await res.json();
                    setGame(data.game);
                    setBetAmount(data.game.blinds.bb * 3);
                    setIsLoading(false);
                    if (data.pendingActionsCount > 0) {
                        await processAIActions();
                    } else {
                        const gtoRes = await fetch(`${API_BASE}/game/gto-recommendation`);
                        const gtoData = await gtoRes.json();
                        setGtoRecommendation(gtoData.recommendation);
                    }
                } catch (err) {
                    console.error(err);
                    setIsLoading(false);
                }
            }, []);

            // アクション評価
            const evaluateAction = (action, amount, recommendation) => {
                if (!recommendation) return null;
                const { fold_percentage, call_percentage, raise_percentage, recommended_raise_amount } = recommendation;
                const recs = [
                    { action: 'fold', percentage: fold_percentage },
                    { action: 'call', percentage: call_percentage },
                    { action: 'check', percentage: call_percentage },
                    { action: 'raise', percentage: raise_percentage }
                ].sort((a, b) => b.percentage - a.percentage);

                const primary = recs[0];
                const secondary = recs[1];
                const userActionType = action === 'check' ? 'call' : action;

                const isPrimary = userActionType === primary.action ||
                    (userActionType === 'call' && primary.action === 'check');
                const isSecondary = secondary && secondary.percentage >= 20 &&
                    (userActionType === secondary.action ||
                     (userActionType === 'call' && secondary.action === 'check'));

                if (userActionType === 'raise' && (isPrimary || isSecondary) && recommended_raise_amount && amount) {
                    const ratio = amount / recommended_raise_amount;
                    if (ratio < 0.5 || ratio > 2.0) {
                        return { result: 'ERROR', message: `レイズアクションは正しいですが、サイズが大きく異なります。推奨: ${recommended_raise_amount}チップ、あなた: ${amount}チップ` };
                    }
                    if (ratio < 0.75 || ratio > 1.5) {
                        return { result: 'ACCEPTABLE', message: `レイズは正しいですが、サイズが少し異なります。推奨: ${recommended_raise_amount}チップ、あなた: ${amount}チップ` };
                    }
                }

                if (isPrimary) return { result: 'CORRECT', message: `素晴らしい！GTO推奨の${primary.action}を選択しました。` };
                if (isSecondary) return { result: 'ACCEPTABLE', message: `許容範囲内です。${secondary.action}は混合戦略の一部として${secondary.percentage}%の頻度で推奨されています。` };
                return { result: 'ERROR', message: `GTO的には${primary.action}が${primary.percentage}%で推奨されています。選択したアクションはEVを損なう可能性があります。` };
            };

            // 統計更新
            const updateStats = (position, situation, action, isCorrect, handData) => {
                setStats(prev => {
                    const n = JSON.parse(JSON.stringify(prev));
                    n.totalHands += 1;
                    if (isCorrect) n.correctActions += 1;
                    if (n.byPosition[position]) {
                        n.byPosition[position].total += 1;
                        if (isCorrect) n.byPosition[position].correct += 1;
                    }
                    const sitKey = situation === 'RFI' ? 'RFI' : 'vsOpen';
                    n.bySituation[sitKey].total += 1;
                    if (isCorrect) n.bySituation[sitKey].correct += 1;
                    const actionKey = action === 'check' ? 'call' : action;
                    if (n.byAction[actionKey]) {
                        n.byAction[actionKey].total += 1;
                        if (isCorrect) n.byAction[actionKey].correct += 1;
                    }
                    return n;
                });

                if (!isCorrect && handData) {
                    setHandHistory(prev => [...prev, {
                        id: Date.now(),
                        timestamp: new Date().toLocaleString('ja-JP'),
                        position,
                        situation,
                        hand: handData.hand,
                        yourAction: action,
                        correctAction: handData.correctAction,
                        gtoPercentages: handData.gtoPercentages
                    }]);
                }
            };

            const performAction = async (action, amount) => {
                if (gtoRecommendation) {
                    const evaluation = evaluateAction(action, amount, gtoRecommendation);
                    if (evaluation) {
                        setFeedback({
                            ...evaluation,
                            userAction: action === 'raise' ? `Raise ${amount}` : action.charAt(0).toUpperCase() + action.slice(1),
                            gtoRecommendation
                        });

                        // 統計更新
                        const hero = game?.players?.find(p => p.isHero);
                        const handNotation = hero ? getHandNotation(hero.holeCards) : null;
                        const situation = game?.firstRaiserPosition ? 'vsOpen' : 'RFI';
                        const isCorrect = evaluation.result === 'CORRECT';

                        // GTO推奨のプライマリアクションを取得
                        const recs = [
                            { action: 'fold', pct: gtoRecommendation.fold_percentage || 0 },
                            { action: 'call', pct: gtoRecommendation.call_percentage || 0 },
                            { action: 'raise', pct: gtoRecommendation.raise_percentage || 0 }
                        ].sort((a, b) => b.pct - a.pct);

                        updateStats(
                            hero?.position || 'UTG',
                            situation,
                            action,
                            isCorrect,
                            {
                                hand: handNotation,
                                correctAction: recs[0].action,
                                gtoPercentages: {
                                    fold: gtoRecommendation.fold_percentage || 0,
                                    call: gtoRecommendation.call_percentage || 0,
                                    raise: gtoRecommendation.raise_percentage || 0
                                }
                            }
                        );
                    }
                }

                setIsLoading(true);
                setGtoRecommendation(null);

                try {
                    const res = await fetch(`${API_BASE}/game/action`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action, amount })
                    });
                    const data = await res.json();
                    setGame(data.game);
                    setIsLoading(false);

                    if (!data.handComplete && data.pendingActionsCount > 0) {
                        await processAIActions();
                    } else if (!data.handComplete) {
                        const gtoRes = await fetch(`${API_BASE}/game/gto-recommendation`);
                        const gtoData = await gtoRes.json();
                        setGtoRecommendation(gtoData.recommendation);
                    }
                } catch (err) {
                    console.error(err);
                    setIsLoading(false);
                }
            };

            // レイズ額計算
            const calcRaiseAmount = (multiplier) => {
                const base = game?.currentBet > (game?.blinds?.bb || 100)
                    ? game.currentBet
                    : (game?.blinds?.bb || 100);
                return Math.min(base * multiplier, hero?.stack || 0);
            };

            // 統計リセット
            const resetStats = () => {
                setStats(JSON.parse(JSON.stringify(initialStats)));
                setHandHistory([]);
            };

            // 派生ステート（useEffectより前に定義）
            const hero = game?.players?.find(p => p.isHero);
            const otherPlayers = game?.players?.filter(p => !p.isHero) || [];
            const currentPlayer = game?.players?.[game?.currentPlayerIndex];
            const isHeroTurn = currentPlayer?.isHero && !currentPlayer?.isFolded && !isProcessingAI;
            const toCall = game ? Math.max(0, (game.currentBet || 0) - (hero?.currentBet || 0)) : 0;
            const pot = game?.pot || 0;

            // キーボードショートカット用 ref（常に最新の関数を参照）
            const performActionRef = useRef(performAction);
            const nextHandRef = useRef(nextHand);
            const calcRaiseAmountRef = useRef(calcRaiseAmount);
            performActionRef.current = performAction;
            nextHandRef.current = nextHand;
            calcRaiseAmountRef.current = calcRaiseAmount;

            // キーボードショートカット
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    const key = e.key.toLowerCase();

                    // ハンド終了時: スペースで次のハンドへ
                    if (game?.isHandComplete || feedback) {
                        if (e.code === 'Space' || e.key === ' ') {
                            e.preventDefault();
                            nextHandRef.current();
                        }
                        return;
                    }

                    // 自分のターンでない場合は無視
                    if (!isHeroTurn) return;

                    switch (key) {
                        case 'f':
                            e.preventDefault();
                            performActionRef.current('fold');
                            break;
                        case 'c':
                            e.preventDefault();
                            performActionRef.current(toCall === 0 ? 'check' : 'call');
                            break;
                        case 'r':
                            e.preventDefault();
                            performActionRef.current('raise', betAmount);
                            break;
                        case '2':
                            e.preventDefault();
                            setBetAmount(calcRaiseAmountRef.current(2));
                            break;
                        case '3':
                            e.preventDefault();
                            setBetAmount(calcRaiseAmountRef.current(3));
                            break;
                        case '4':
                            e.preventDefault();
                            setBetAmount(calcRaiseAmountRef.current(4));
                            break;
                        case 'a':
                            e.preventDefault();
                            setBetAmount(hero?.stack || 0);
                            break;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [game?.isHandComplete, feedback, isHeroTurn, toCall, betAmount, hero?.stack]);

            useEffect(() => { startNewGame(); }, [startNewGame]);

            const getSeatClass = (playerIndex) => `seat-player-${playerIndex}`;

            return (
                <div className="game-container">
                    {/* ヘッダー2段構成 */}
                    <header className="header">
                        <div className="header-top">
                            <span className="app-title">GTO Trainer</span>
                            <span className="blinds-info">SB/BB: {game?.blinds?.sb || 50}/{game?.blinds?.bb || 100}</span>
                        </div>
                        <div className="control-bar">
                            <div className="tab-buttons">
                                <button
                                    className={`tab-btn ${leftPanelMode === 'range' ? 'active' : ''}`}
                                    onClick={() => setLeftPanelMode('range')}
                                >
                                    レンジ表
                                </button>
                                <button
                                    className={`tab-btn ${leftPanelMode === 'stats' ? 'active' : ''}`}
                                    onClick={() => setLeftPanelMode('stats')}
                                >
                                    統計
                                </button>
                            </div>
                            <button
                                className={`toggle-btn ${showGTOPanel ? 'active' : 'inactive'}`}
                                onClick={() => setShowGTOPanel(!showGTOPanel)}
                            >
                                {showGTOPanel ? 'GTO推奨 \u2715' : 'GTO推奨 \u25CB'}
                            </button>
                        </div>
                    </header>

                    {/* コンテンツエリア */}
                    <div className={contentClass}>
                        {/* 左パネル - レンジ表 or 統計 */}
                        <div className="left-panel">
                            {leftPanelMode === 'range' ? (
                                <RangePanel
                                    heroPosition={hero?.position || 'UTG'}
                                    heroHand={hero?.holeCards}
                                    firstRaiser={game?.firstRaiserPosition}
                                />
                            ) : (
                                <StatsPanel
                                    stats={stats}
                                    history={handHistory}
                                    onReset={resetStats}
                                />
                            )}
                        </div>

                        {/* メインエリア */}
                        <div className="main-area">
                            <div className="table-area">
                                {game && (
                                    <div className="poker-table">
                                        <div className="table-felt">
                                            <div className="community-area">
                                                <div className="text-white text-sm mb-2">
                                                    Pot: <span className="text-yellow-400 font-bold">{pot.toLocaleString()}</span>
                                                </div>
                                                <div className="community-cards">
                                                    {[0,1,2,3,4].map(i => (
                                                        game.communityCards[i] ? (
                                                            <Card key={i} card={game.communityCards[i]} size="sm" />
                                                        ) : (
                                                            <div key={i} className="card card-sm" style={{border: '2px dashed rgba(255,255,255,0.2)', background: 'transparent'}} />
                                                        )
                                                    ))}
                                                </div>
                                                <div className="text-gray-300" style={{fontSize: '10px'}}>{game.currentStreet?.toUpperCase()}</div>
                                            </div>
                                        </div>
                                        {otherPlayers.map((player) => (
                                            <PlayerSeat
                                                key={player.id}
                                                player={player}
                                                isActive={game.players.indexOf(player) === game.currentPlayerIndex}
                                                seatClass={getSeatClass(player.playerIndex)}
                                            />
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* ヒーローエリア */}
                            <div className="hero-area">
                                {hero && (
                                    <>
                                        <div className="hero-cards">
                                            <Card card={hero.holeCards?.[0]} size="lg" />
                                            <Card card={hero.holeCards?.[1]} size="lg" />
                                        </div>
                                        <div className="hero-info">
                                            <div style={{marginBottom: '4px'}}>
                                                <span className={`pos-badge pos-${hero.position}`}>{hero.position}</span>
                                                <span className="text-white text-sm font-bold ml-2">あなた</span>
                                            </div>
                                            <div className="text-yellow-400 font-bold">{hero.stack.toLocaleString()}</div>
                                            {hero.currentBet > 0 && (
                                                <div className="text-green-400 text-sm">Bet: {hero.currentBet}</div>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>

                            {/* アクションエリア */}
                            <div className="action-area">
                                {isProcessingAI ? (
                                    <div className="processing-indicator">
                                        <div className="spinner" />
                                        <span>{currentPlayer?.name || 'AI'} がアクション中...</span>
                                    </div>
                                ) : isHeroTurn ? (
                                    <>
                                        <div className="action-row">
                                            <button className="action-btn btn-fold" onClick={() => performAction('fold')} disabled={isLoading}>
                                                <span>フォールド</span>
                                                <span className="shortcut">F</span>
                                            </button>
                                            <button
                                                className={`action-btn ${toCall === 0 ? 'btn-check' : 'btn-call'}`}
                                                onClick={() => performAction(toCall === 0 ? 'check' : 'call')}
                                                disabled={isLoading}
                                            >
                                                <span>{toCall === 0 ? 'チェック' : 'コール'}</span>
                                                {toCall > 0 && <span className="amount">{toCall}</span>}
                                                <span className="shortcut">C</span>
                                            </button>
                                            <button className="action-btn btn-raise" onClick={() => performAction('raise', betAmount)} disabled={isLoading}>
                                                <span>レイズ</span>
                                                <span className="amount">{betAmount}</span>
                                                <span className="shortcut">R</span>
                                            </button>
                                            <div style={{display: 'flex', gap: '6px', marginLeft: '8px'}}>
                                                {[{label: '2x', mult: 2, key: '2'}, {label: '3x', mult: 3, key: '3'}, {label: '4x', mult: 4, key: '4'}, {label: 'ALL', mult: 'ALL', key: 'A'}].map(({label, mult, key}) => {
                                                    const amt = mult === 'ALL' ? (hero?.stack || 0) : Math.min((game?.currentBet > (game?.blinds?.bb || 100) ? game.currentBet : (game?.blinds?.bb || 100)) * mult, hero?.stack || 0);
                                                    const isActive = betAmount === amt;
                                                    return (
                                                        <button
                                                            key={label}
                                                            className={`size-btn ${isActive ? 'active' : ''}`}
                                                            onClick={() => setBetAmount(amt)}
                                                            title={`キー: ${key}`}
                                                        >
                                                            {label}
                                                        </button>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    </>
                                ) : (
                                    <div className="waiting-message">
                                        {game?.isHandComplete ? (
                                            <div>
                                                <span className="text-yellow-400 font-bold text-lg">ハンド終了！</span>
                                                <button
                                                    onClick={nextHand}
                                                    className="ml-4 bg-blue-600 text-white px-4 py-2 rounded font-medium hover:bg-blue-700"
                                                >
                                                    次のハンドへ
                                                </button>
                                                <div style={{color: '#9ca3af', fontSize: '11px', marginTop: '6px'}}>
                                                    スペースキー
                                                </div>
                                            </div>
                                        ) : (
                                            <span>{currentPlayer?.name || 'AI'} のターン...</span>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* 右パネル - GTO推奨 */}
                        {showGTOPanel && (
                            <GTOPanel
                                recommendation={isHeroTurn ? gtoRecommendation : null}
                                onClose={() => setShowGTOPanel(false)}
                            />
                        )}
                    </div>

                    {/* フィードバックモーダル */}
                    <FeedbackModal
                        feedback={feedback}
                        onNextHand={nextHand}
                    />
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
